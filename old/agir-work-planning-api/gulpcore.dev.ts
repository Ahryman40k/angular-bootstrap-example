// ==========================================
// Gulp dev tasks
//
// Those tasks are tasks that will only be available
// when the dev dependencies are installed. They
// won't be when the applicatin is started in Docker
// by default!
//
// This file will be transpiled and included
// by the standard Gulp file "gulpfile.js".
//
// Console output is OK in Gulp tasks!
// tslint:disable:no-console
// ==========================================
import {
  prettierCheck,
  prettierFix,
  ProjectType,
  tslintCheck,
  tslintFix
} from '@villemontreal/lint-config-villemontreal';
import * as del from 'del';
import * as express from 'express';
import * as fs from 'fs-extra';
import * as glob from 'glob';
import { series, task, TaskFunction, watch as gulpWatch } from 'gulp';
import * as path from 'path';
import * as yargs from 'yargs';

import { configs } from './config/configs';
import { EndpointTypes } from './config/constants';
import { configureOpenApi } from './open-api/openApiConfigurer';
import { createDefaultApp } from './src/core/app';
import { validateApp } from './src/utils/appValidator';
import { appUtils, utils } from './src/utils/utils';
import { TokenGenerator } from './tests/load/privilegeJwt';

const execSync = require('child_process').execSync;
const notifier = require('node-notifier');
// tslint:disable: prefer-template
// ==========================================
// Clean .js and .js.map generated by
// transpilation.
// ==========================================
const filterjs = (file: string) => {
  return file.replace(/.ts$/, '.js');
};
const filterjsmap = (file: string) => {
  return file.replace(/.ts$/, '.js.map');
};

function clean() {
  return glob(
    './**/*.ts',
    {
      ignore: ['./node_modules/**/*.ts']
    },
    (err, files) => {
      del(files.map(filterjs))
        .then(() => {
          return del(files.map(filterjsmap));
        })
        .then(() => {
          console.info('Cleanup done...');
        })
        .catch((error: any) => {
          console.info(`Unable to clean the project : ${error}`);
        });
    }
  );
}

// ==========================================
// Lint check
// ==========================================
const lint = series(prettier, tslint);

// ==========================================
// Lint fix
// ==========================================
const runLintFix = series(runPrettierFix, runTslintFix);

// ==========================================
// Prettier check
// ==========================================
async function prettier() {
  await prettierCheck(configs.root);
  console.info('Prettier check succesful!');
}

// ==========================================
// Prettier fix
// ==========================================
async function runPrettierFix() {
  await prettierFix(configs.root);
  console.info('Prettier fix succesful!');
}

// ==========================================
// TSLint check
// ==========================================
async function tslint() {
  await tslintCheck(configs.root, ProjectType.NODE);
  console.info('TSLint check succesful!');
}

// ==========================================
// TSLint fix
// ==========================================
async function runTslintFix() {
  await tslintFix(configs.root, ProjectType.NODE);
  console.info('TSLint fix succesful!');
}

// ==========================================
// Tests - Load
//

// ==========================================
async function testLoad() {
  // ==========================================
  // Get an access token/id token
  // ==========================================
  const tokenGenerator = new TokenGenerator();
  const token: string = await tokenGenerator.getAuthorizationToken(
    configs.gluu.serviceAccount.username,
    configs.gluu.serviceAccount.password
  );

  if (token === undefined) {
    console.log('Could not generate token');
    process.exit(1);
  }

  // ==========================================
  // Replaces the "${HOST}" and "${PORT}" in the
  // Artillery config file...
  // ==========================================
  let content: string = fs.readFileSync(`${configs.root}/tests/load/artillery.yaml`, 'utf-8');
  content = content.replace('${SCHEME}', 'http');
  content = content.replace('${HOST}', configs.api.host);
  content = content.replace('${PORT}', configs.server.port + '');
  content = content.replace('${TOKEN}', token);
  // content = content.replace('${numberOfloopCount}', `${configs.getArtilleryCount.artillery}`);
  const fileTmpPath = `${configs.testDataDirPath}/artillery-config.yaml`;
  fs.writeFileSync(fileTmpPath, content, 'utf-8');

  const logFilePath = `${configs.testDataDirPath}/artillery-results.json`;

  // ==========================================
  // Runs Artillery
  // ==========================================
  await utils.execPromisified('node', [
    `${configs.root}/node_modules/artillery/bin/artillery`,
    'run',
    '--output',
    logFilePath,
    fileTmpPath
  ]);
  await afterTest();
}

// ==========================================
// Debug task
// ==========================================
function debug() {
  // ==========================================
  // We require it here so we can set the
  // "gulp-nodemon" library as a devDependencies...
  // ==========================================
  const nodemon = require('gulp-nodemon');

  gulpWatch(['./*.ts', './!(node_modules)/**/*.ts'], () => {
    console.info('Compilation...');
    execSync('"node_modules/.bin/tsc"', { stdio: [0, 1, 2] });
    console.info('Compilation done.');
  });
  nodemon({
    script: `${configs.root}/src/start.js`,
    nodeArgs: [`--inspect=${configs.debug.host}:${configs.debug.port}`, '--nolazy'],
    ext: 'js',
    restartable: true
  });
}

// ==========================================
// Serves the Swagger editor only
// ==========================================
function editor() {
  if (configs.openApi.exposeSwaggerEditor) {
    const app = express();
    configureOpenApi(app, true, true, false, configs.server.swaggerEditorAlonePort);

    app.listen(configs.server.swaggerEditorAlonePort, () => {
      const swaggerEditorAloneUrl = appUtils.createPublicUrl(
        configs.routing.routes.openAPI.editor,
        EndpointTypes.DOCUMENTATION,
        configs.server.swaggerEditorAlonePort
      );

      console.info(`\n==========================================`);
      console.info(`Swagger editor running...\n`);
      console.info(`${swaggerEditorAloneUrl}`);
      console.info(`==========================================\n`);
    });
  } else {
    console.info(`The Swagger editor is disable.`);
  }
}

// ==========================================
// Tests everything :
// - Lintage
// - Application validation
// - Integration/unit Tests
// ==========================================
async function afterTest() {
  console.info(`\n==========================================`);
  console.info(`All tests and validations passed!`);
  console.info(`==========================================\n`);
  return Promise.resolve(true);
}

const test = series(lint, validate, testUnits, afterTest);

// ==========================================
// Runs the tests and output a report for
// Jenkins.
// The path to the report to generate can be
// passed :
// - as a command line param :
//   "npm run test-jenkins -- --report=output/test-results/report.xml"
// - as an "JUNIT_REPORT_PATH" environment variable.
// By default, the path will be "output/test-results/report.xml"
// ==========================================

async function beforeTestJenkins() {
  if (yargs.argv.report) {
    process.env.JUNIT_REPORT_PATH = yargs.argv.report as string;
  } else if (!process.env.JUNIT_REPORT_PATH) {
    process.env.JUNIT_REPORT_PATH = 'output/test-results/report.xml';
  }
  process.env.TZ = 'America/Montreal';
  return Promise.resolve(true);
}

const testJenkins = series(beforeTestJenkins, test);

// ==========================================
// Tests - units and integration
//
// Will find all files ending in ".test.js" under the
// "src" and the "tests" folders.
//
// If a "JUNIT_REPORT_PATH" environment variable is set,
// a report for Jenkins will be generated.
// ==========================================
// tslint:disable-next-line:adjacent-overload-signatures
async function testUnits() {
  const args = [
    `${configs.root}/node_modules/nyc/bin/nyc.js`,
    `${configs.root}/node_modules/mocha/bin/_mocha`,
    `--opts`,
    `mocha-nyc.opts`
  ];

  // ==========================================
  // Stop testing as soon as one test fails?
  // ==========================================
  if (yargs.argv.bail) {
    args.push('--bail');
  }

  if (process.env.JUNIT_REPORT_PATH) {
    console.info('Exporting tests to junit file ', process.env.JUNIT_REPORT_PATH);
    args.push('--reporter');
    args.push('mocha-jenkins-reporter');
  }

  try {
    await utils.execPromisified('node', args);
    console.info('All unit/Integration tests done.');
  } catch (err) {
    console.error(`Some unit/integration tests failed : ${err}`);
    throw err;
  }
}

// ==========================================
// Validates the application
// ==========================================
async function validate() {
  const app = await createDefaultApp();

  await validateApp(app);
  console.info('The application is valid!');
}

// ==========================================
// NPM post-install script
// ==========================================
function postinstall() {
  // Nothing to do for the moment
  return Promise.resolve(true);
}

// ==========================================
// Incremental compilation.
// To be launched in a dedicated terminal. Use
// "CTRL-C" to terminate it.
//
// Can be used with the "fast" versions of the
// launch configurations provided for VS Code for
// quick development.
//
// You can enable or disable incremental compilation
// notifications using the
// "configs.debug.watch.notifications.enabled"
// configuration (turned off by default)
// ==========================================
async function watch() {
  console.info(
    `\n==========================================\n` +
      `Starting incremental compilation...\n` +
      `==========================================\n\n`
  );
  const projectName = require(configs.root + '/package.json').name;
  let ignoreNextCompilationComplete = false;
  const compilationCompletetRegEx = /Compilation complete/;
  const errorRegEx = /(: error)|(error)/;

  const dataHandler = (stdoutData: string, stderrData: string): void => {
    if (stdoutData) {
      const stdoutDataClean = stdoutData.toString();
      console.log(stdoutDataClean);

      if (!configs.debug.watch.notifications.enabled) {
        return;
      }

      let error = false;
      if (errorRegEx.test(stdoutDataClean)) {
        error = true;
        notifier.notify({
          title: projectName,
          message: 'incremental compilation error',
          icon: path.normalize(configs.root + '/.local/notifications/error.png'),
          sound: configs.debug.watch.notifications.sound
        });
      } else if (compilationCompletetRegEx.test(stdoutDataClean)) {
        if (!ignoreNextCompilationComplete) {
          notifier.notify({
            title: projectName,
            message: 'incremental compilation done',
            icon: path.normalize(configs.root + '/.local/notifications/success.png'),
            sound: configs.debug.watch.notifications.sound
          });
        }
      }

      ignoreNextCompilationComplete = error && !compilationCompletetRegEx.test(stdoutDataClean);
    }
    if (stderrData) {
      console.error(stderrData);
    }
  };

  while (true) {
    try {
      await utils.execPromisified(
        'node',
        [`${configs.root}/node_modules/typescript/lib/tsc.js`, '--project', configs.root, '--watch', '--pretty'],
        dataHandler
      );
    } catch (err) {
      console.error('Error, restarting incremental compilation in a second : ' + err);
      await utils.sleep(1000);
    }
  }
}

exports = {
  clean,
  debug,
  editor,
  watch,
  test,
  'test-load': testLoad,
  'test-units': testUnits,
  'test-jenkins': testJenkins,
  lint,
  'lint-fix': runLintFix,
  tslint,
  'tslint-fix': runTslintFix,
  prettier,
  'prettier-fix': runPrettierFix,
  validate,
  postinstall
};

// for some reason, the previous exports are not accessible by the require() call in gulpfile.js
// so, we provision the tasks explicitely.
for (const [k, v] of Object.entries(exports)) {
  task(k, v as TaskFunction);
}
